"The Castle"
http://www.camelot.homedns.org/~michalis/castle.php

--------------------
Levels included:

The actual game consists of 3 levels. There's also 1 hidden debugging level.

I used to have here a description and walkthorugh of the levels,
but it's probably more fun to just go and play them.
So that's all I'm going to say about levels.

If you're interested in designing levels (making new levels or
modifying existing levels), more information is lower in this file.

If you want to see other models demonstrating my engine, see
[http://www.camelot.homedns.org/~michalis/miscella/kambi_vrml_examples.zip]
--- there are many testcases and demos of what can be expressed in VRML 1.0
and what my engine can understand and render. See also
[http://www.camelot.homedns.org/~michalis/view3dscene.php] ---
view3dscene is my VRML 1.0 (and 3DS) viewer based on the same engine as
this game.

--------------------
Creating levels, 3d objects for my games:

The short 1-sentence instruction is:
Use any 3d modelling program able to create VRML 1.0 files.

VRML 1.0 format has an official specification and my engine is capable
of handling any VRML 1.0 valid files (actually, even more than that ---
see [http://www.camelot.homedns.org/~michalis/kambi_vrml_extensions.php]).
So my engine is not tied to any particular modelling program.
Use [http://www.camelot.homedns.org/~michalis/view3dscene.php]
to view the various models outside of the game.

My favourite 3d modeller is Blender, [http://www.blender3d.org/].
It's open source, it's available for Linux (yeah, Windows too
if you insist :), and it has an enormous set of features.
Including good export for VRML 1.0, of course. There are no special
rules for designing in Blender models for my engine --- basically
just do whatever you like (and whatever can be exported to VRML 1.0).
Below I offer some hints.

I often "wrap" (using WWWInline VRML construction) models produced by
Blender inside some small VRML files written by hand.
For example, data/levels/castle_hall_final.wrl is a small VRML file that is
maintained by hand. It sets up some things that were uncomfortable
(or impossible, due to lacks of VRML 1.0 exporter) to set up from Blender,
and includes (using WWWInline node) other VRML file
(data/levels/castle_hall_processed.wrl in this case) that defines geometry,
materials and textures of the level.

Typical things that I write "by hand" are

- Background, NavigationInfo nodes

  These nodes were introduced in VRML 2 (although I implemented them
  for VRML 1 also). So Blender exporter to VRML 1 does not write
  these nodes. So I just write them by hand.

- PerspectiveCamera node

  Blender exports camera settings, but in an uncomfortable
  format (as a transformation, instead of as VRML camera node).
  This is OK for simple viewing of VRML models, but it's not OK
  if you want to "tweak" VRML models. In particular, it's bad
  when you want to add Background node (see above) and light nodes
  (see hints below) by hand. Then you have to either insert it
  into the middle of Blender's generated VRML file, or use awkward
  coordinates (because of additional transformation).
  So I usually generate camera node by opening model in my view3dscene
  (see [http://www.camelot.homedns.org/~michalis/view3dscene.php])
  and using "Print current camera node (Ctrl+C)" feature.

- Light nodes

  I usually write light nodes in a separate VRML file
  (that contains only light nodes; see e.g. data/levels/castle_hall_lights.wrl).
  This is comfortable, because I usually want to use level lights
  also on other objects (like enemies) that are not part of the level
  object.

  (Also, while Blender exporter can export Blender lights to VRML,
  it doesn't allow me to use all features of VRML lights.)

  Since version 0.5.7 you can also edit the lights from the game
  --- see "Debug options" menu for "Edit lights" command.
  So you have to add appropriate nodes to xxx_lights.wrl
  file by hand, and then you can just run the game and configure lights
  properties from the game.

Moreover, I sometimes want to post-process VRML files generated from
Blender. I use EmacsLisp macros for this (since this is a great language
for text operations, and it's built in my favourite editor :) ).
For example data/levels/castle_hall.wrl in VRML file
exported from Blender (from data/levels/castle_hall.blend),
and it's processed to data/levels/castle_hall_processed.wrl.

3DS notes: Actually, you can also use models in 3DS format instead
of VRML 1.0. So if your favourite 3d modelling program is not able to export
to VRML 1.0 but it's able to export to 3DS --- you can use it too.
But, since 3DS is a closed format, it will never be supported
completely by my engine (just like by any other program, since everyone
has to decode 3DS). In particular, *everything* that can be expressed
in 3DS format and that is understood by me engine can also be expressed
in VRML 1.0. But not vice-versa, i.e. there are some features that
are available with my engine when using VRML 1.0 but are not available
when using 3DS. So the bottom line is: well, you can use 3DS format
with my engine, it works OK, but VRML 1.0 format is just better :)

--------------------
Creating levels, 3d objects for *this* game:

Section above had general comments about how anyone can create
levels and 3d objects that are useful for my VRML units.
This section describes issues specific to the game "The Castle":

Levels:

- The very concept of this game (much like any other modern game)
  is that you can design new levels without writing a single line
  of "real" (in this case: ObjectPascal) code.
  For simple start, if you want to play around, you can start
  by modifying some existing level, like the "Tower" level
  (see files data/level/basic_castle_*).

- When loading level, we search for node named 'LevelBox'.
  Such node should be a parent of some shape (e.g. IndexedFaceSet)
  node. (In other words: in Blender just add a mesh (usually a cube)
  and name it 'LevelBox').

  When such node is found, we calculate it's BoundingBox and remove
  it from the scene. Calculated BoundingBox becomes Level.LevelBox
  value. And Level.LevelBox is used to limit allowed player positions.
  This can be used to disallow player to move to the very edge of
  the level.

  Usually you will add 'LevelBox' node using Blender, you can also
  use my view3dscene --- see command
  'Console -> Print scene bounding box as VRML node'.

- Similar to 'LevelBox', I do identical trick to calculate
  'HintButtonBox'. This is the box that will trigger message
  "Hint: you can press the button by clicking on it".

- Similar to 'LevelBox', I do identical trick to calculate
  water boxes. Just place a mesh with name 'WaterBox'.
  At some point this will be extended (when I'll need it) to
  include every 'WaterBox_<ignored>', so that you will be able to
  define water by a sum of boxes.

- Levels must be oriented such that +Z is "up".
  While all things in my general units are flexible
  and allow any up vector to be used, I made in "The Castle" a couple
  of assumptions that really need +Z to be up.
  (like TItemOnLevel.PlayerCollision).

- All levels should keep the same general sizes. In other words,
  it's *not good* to just make your new level of arbitrary
  size and then set player's avatarSize such that things "look sensible".
  Why ? Because I place items and enemies on the level.
  So size of all these various models must match.

  In other words: just make sure you use
    NavigationInfo {
      avatarSize [ 0.5, 2 ]
      speed 1.0
      ...
    }
  in your level. And force yourself to design a level that "fits"
  such avatarSize and speed.

- Sectors and waypoints (aka portals) for the level:
  - Shapes placed under the name Sector<index>_<ignored>
    are removed from the real level in TLevel constructor.
    The geometry of given sector is understood to be the sum
    of all Sector<index> boxes.

    Also VisibleSectors for each sector are coded in CastleLevel.pas unit.

    For programmers: in cases when the sum of bounding boxes
    is not flexible enough to define a geometry,
    you can define any kind of geometry in Pascal code,
    by overriding TSceneSector.IsPointInside.
    In the future, treatment of the shape inside Sector<index>_<ignored>
    may change, so that any kind of closed shape will be allowed there
    and it will be stored and used precisely (not only as it's bounding box).

    Remember that sectors are numbered starting from 0.

  - Shapes placed under the name Waypoint<index>_<ignored>
    are also removed from the real level in TLevel constructor.
    Middle point of bounding box of such shape determines
    waypoint's Posiiton.
    Remember that waypoints are numbered starting from 0.

  - Sectors of waypoints (and reverse property, Waypoints
    of sectors) are automatically calculated, by looking for waypoints
    that have a Position that falls inside Sector's BoundingBoxes
    enlarged by margin 0.5.

    Note that sectors' BoundingBoxes need *not* be strictly separated.
    When object (like player or creature) is within two sectors,
    it's arbitrarily assigned to any allowed sector.
    And for the rendering optimization, such sectors would work fine.
    However, for monster AI, sectors should not have any common
    large non-zero volume.

    So in practice, each sector should usually place
    waypoint's Position at it's border. Sectors may overlap but only
    for a minimal distance (otherwise awkward movement may happen
    when creature is in the common part).

  - You don't have to cover whole level with sectors.
    If some object (like player or creature) is not within any defined
    sector, it's considered to be inside the "implicit whole sector",
    that is a little special. It's geometry is considered
    infinte (every 3D point belongs to it, if it doesn't belong to any
    of the explicitly defined scetors). VisibleSectors
    is treated like filled with values "true" (so all other sectors
    are assumed to be visible).

    For programmers: SectorWithPoint returns nil when no sector found,
    and this indicates such "implicit whole sector".
    FindWay accepts SectorBegin and SectorEnd as nil
    (and always returns then false).

  - Sectors and waypoints are used for 2 things:

    1. To speed up rendering: When player's CameraPos is within
       a given sector (not nil), we have to render only the sectors
       for which VisibleSectors is true.
       TODO: right now it's not used for to speed up rendering,
       and VisibleSectors is ignored.

    2. To make creature moving AI more intelligent:
       If a creature wants to move from SectionBegin to SectorEnd,
       and SectionBegin <> SectorEnd (and none of them is nil),
       creature knows that it must pass through appropriate waypoints.

    It's assumed that there will not be too many sectors on the level
    (100 sectors is *really* around maximum. 10-20 is reasonable.)
    So sectors are *not* (at least right now) stored in any "intelligent"
    structure (like an octree) and creature moving AI uses
    the simplest search on the graph to find a satisfiable path
    (no A* algorithm or anything; it's simply not needed for the kind of
    sectors layouts that I will typically use).

- If you made a completely new level, you want to add it to the game.
  You have to add a little code for this:

  To add your level to the list of levels available from
  debug command "Change to level": implement new TLevel descendant
  (overriding it's abstract methods). For simplest example see
  how TTowerLevel is defined in CastleLevel, it's really trivial.
  Also add
    LevelsAvailable.AddLevelClass(TYourLevel);
  call to initialization.

  To additionally make your level part of the actual game
  (i.e. reachable by normal player, not using any debug/cheat commands):
  - You can replace the call above with
      LevelsAvailable.AddLevelClass(TYourLevel, true);
    This will add your level to levels available in "New Game" menu by default.
  - You can add somewhere the call to LevelFinished(TYourLevel.Create),
    so that player is in some situation transferred from other level
    to your level.

  Note that when starting "New Game" player can choose to start
  from any level that he (she ? :) previously visited ("visited"
  either as part of normal game story of through debug command
  "Change to level"). This feature may be removed in the future when
  real "Save game" / "Load game" feature will be implemented.

  If you don't mind a little programming, you may want to add
  more interesting code to your TYourLevel implementation.
  See existing level implementations for examples what can be achieved.
  You may even want to move your new level class
  to a completely separate unit file if you want
  (but keep LevelsAvailable.AddLevelClass call inside CastleLevel
  initializaition).

Items:

- Item up vector must be +Z.

- Item should be oriented such that:

  Z = 0 plane is the base plane of the item. It will be aligned with the base
  (i.e. lowest Z) of "stub" object placed on the level.

  X = 0 and Y = 0 is the line around which object will rotate
  when shown on the level. It will be aligned with the X, Y middle
  of "stub" object placed on the level.

  I had an idea to just automatically take item's bounding box,
  it's middle X, Y and lowest Z and automatically adjust to this.
  But this would disable some possible visual tricks.

- Size of item model is exactly the size that will be used to display
  it on level, so set this to look good. Sensible default
  is size around 1.0.

- About the "stub" objects on the level:

  You can place items on the level by placing a "stub" object
  on the level with appropriate name.

  When loading, I search for shape nodes that have a parent node
  named like "Item<item-kind-name><quantity>_<ignored>".
  Where "<item-kind-name>" is "LifePotion" or "Sword" or any
  other TItemKind.VRMLNodeName value (see CastleItems unit),
  "<quantity>" is, well, the integer quantity
  ("1" is assumed if "<quantity>" is omitted), and "<ignored>"
  is just anything that will be ignored (you can use this
  to make object names in your model unique,
  which is obviously desirable).

  Some reasoning about convention above: Blender's names
  have quite limited length, that's why CamelCase is used
  for "<item-kind-name>" and components are generally "glued"
  without any "_" or "-" or " " between.

  Such "stub" object is removed from the actual level and
  instead I insert into level an item. Item position is determined
  by stub lowest Z and middle X,Y line (see above).

  You can easily insert such "stub" with Blender --- just insert
  any shape (I usually insert Cube, and set it's rendering to
  "wireframe" in Blender), and then edit Blender's mesh name
  as appropriate.

- Prepare appropriate 2d image of item (to be shown in inventory slots etc.).
  (Once I tried just automatically rendering models inside inventory slots
  but this doesn't look good enough). You can do it however you like.

  One way to do it is to use my raytracer, called rayhunter
  ([http://www.camelot.homedns.org/~michalis/rayhunter.php]):
  set up appropriate light and camera settings and then just render
  item's model to the image. data/items/images/sword.png is done like this.

  Another is to open a model with view3dscene
  ([http://www.camelot.homedns.org/~michalis/view3dscene.php]),
  set your camera however you like and make a screenshot.
  Then you can edit it in whatever program you like
  (like GIMP) to suit your needs.

  Note that all items' images must be of equal size.
  See data/items/images/Makefile for IMAGE_WIDTH and IMAGE_HEIGHT constant.

- If this is a weapon, then additionally you want to prepare what I call
  a ScreenImage of this weapon --- this will be displayed on player's
  screen when it's equipped. See data/items/equipped/.

  Once again, you can do this image however you like.
  I used rayhunter to render screen for sword.

  You must also prepare an animation of "swinging" the weapon.
  See data/items/attack_animations/.

- Finally, to really add the item to the game add 1 line to
  CastleItems units in DoInitialization call creating your
  TItemKind instance.

- For some items you may be able to just reuse some existing TItemKind
  class, for others you will want to derive new class from TItemKind
  and override there things you want.

- For technical reasons, whole item should use either *only transparent
  materials* or *only non-transparent materials*. Otherwise rendering
  in some special cases could get wrong. In the code you should set
  Transparent property to true if this item is transparent.

Creatures (enemies etc.):
- Several notes about items apply also to creatures:

  - Up vector must be +Z.
    Moreover, for creatures: the looking direction
    (i.e. whatever should be considered the "front" of the creature)
    should be +X.

  - Z = 0 is the base plane (ground) of the creature
  - X = 0 and Y = 0 is the middle of the creature on XY plane

  - Size of creature's model as rendered in the game is exactly
    the size of it's model. A good reference is player's camera
    height: 2. So creatures have generally height around 2.

  - Like with items, initial creatures positions can be set
    by placing a "stubs" on the level. Name of stub object is like
    "Crea<creature-kind-name>_<ignored>".
    Creature position is determined by stub lowest Z and
    middle X,Y line.

    Moreover, for creatures: initial creature direction
    is determined by ... TODO: right now starting creature direction
    just points into player starting position.
    This is more-or-less sensible, usually.
    But it's meant to be comfortably configurable in scene file in the future.

  - To really add the creature to the game add 1 line to
    CastleCreatures unit in DoInitialization call creating your
    TCreatureKind instance.

  - For some creatures you may be able to just reuse some existing TCreatureKind
    and TCreature descendants, for others you will want to derive
    your own descendants.

  - Whole creature should use either *only transparent
    materials* or *only non-transparent materials*.
    See TObjectKind.Transparent documentation for reasoning.

- For simple customizations you can set various creature
  parameters by editing data/creatures/kinds.xml file.

- For testing various animations of creatures (and adjusting their time
  parameters) you can use my demo_animation program
  (see units/3dmodels.gl/examples/demo_animation.dpr).

- Notes for animations: beware. Animations are done with a method
  that essentially makes their rendering very fast (rendering each
  animation frame should be as fast as if it was a still scene).
  However it costs much in terms of memory consumption (and in
  "Loading creatures" time). Some features that should be avoided:

  - Different material for each vertex. This is taken from vertex painting
    in blender. I.e. you can leave vertex painting as generated (incorrectly)
    by blender, as PER_VERTEX_INDEXED. If you fix it to PER_VERTEX your
    models will take a lot of more memory space. E.g. for SpiderQueen
    this is 270 MB with vertex painting vs 80 MB without vertex painting
    (triangle count is 2715).

Sounds:

- Special notes for creating footsteps:
  - Don't make the footsteps sound too long.
    Preferably you should put there only 2 footsteps. Reason ?
    When progress is displayed (e.g. because player changes levels),
    or when player enters the game menu, footsteps sond is not
    immediately stopped --- it's just player until the end.
    Yes, this is desired, as it makes better effect than suddenly
    stopping all the sounds.
  - These 2 footsteps should take about 1 second. This is the amount
    of time that "feels good" with player speed and head bobbing.

- Remember that if sounds are supposed to be spatialized (i.e. played
  by Sound3d procedures), then you must make them mono (never stereo!).
  That's because Windows OpenAL will never spatialize stereo sounds.

  You can use any editor you like to convert your sounds to mono.
  I like this sox command-line:
    sox input.wav -c 1 output.wav
  See also data/sounds/scripts/example_make_mono.sh

--------------------

--------------------
Have fun! All comments are welcome.

Michalis Kamburelis
http://www.camelot.homedns.org/~michalis/
<kambi@users.sourceforge.net> (or <michalis@camelot.homedns.org>)