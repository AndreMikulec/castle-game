"The Castle"

--------------------
PGD competition stage 3 short notes:

- Items: done.
  You can pick items (just walk on them),
  browse your items (keys: i, [, ]),
  drop (key: d),
  equip and use (key: enter; unequipping happens automatically on drop).

  Items are "stackable", i.e. when you own two or more items
  of the same kind, they are displayed like one item with quantity N.
  Picking and dropping handle this appropriately (when dropping you
  can drop only part of owned items).

  See below in this file for description how you can design new
  items for this game.

  After stage 3: You can point with your mouse at item lying on the level,
  this tells you the name and quantity of visible object.
  (of course, if object is too far, you will not be able to tell it exactly).

  TODO: Things remaining to be done about items are:
  - You can't swing your weapon right now and hurt anyone
    (especially because there are no enemies right now...).
  - More items should be added, right now there are only 2.

- New level and level exit:
  Yes. See section "Sample levels included" below.

- Enemies: not done (not enough time...)
  So I guess that I should get only 15 points for stage 3...

--------------------
Installing and running:

- For Linux:

  Extract the archive, move the whole `castle' directory to
  - /usr/local/share/castle/ (for system-wide install) or
  - $HOME/.castle.data/ (for installation only for you)
  To make it clear: you should get directories like
  /usr/local/share/castle/data/ or ~/.castle.data/data/ then.

  Run the executable "castle".

- For Windows:

  Extract the archive anywhere you want.

  Run the executable "castle.exe".

Some general notes about command-line options understood by all my
programs are here:
[http://www.camelot.homedns.org/~michalis/common_options.php].

For good performance you need also good OpenGL drivers
for your graphics card installed.

--------------------
Sample levels included:

"Sample castle level" : this is a simple level submitted for PGD stage 2.
  This is actually combined from my old demo castle model,
  and I added night sky with moon that was used in
  my other toy-game (named "lets_take_a_walk").
  Looks good as a demo, but it was not really intended to be used in this game,
  I just added this for stage 2.

"Castle hall" : this is the level made for PGD stage 3.
  It's not finished yet (of course :) ), but it exists and there is level exit.

  Walkthrough: there is a red button that you should "push" (click with mouse)
  and then take a look at the main hall --- you will see some
  animation and level exit will be revealed.

  In a final version, this button will be on the glass roof
  (the thing hanging in the middle of the level), and stairs
  will lead to this roof. But stairs are not modelled now, so I just placed
  the red button on the other side of the corridor for now...

  Still you can use "f" key (toggles "flying mode", in the final game
  this will require some item, spell etc.) to stand on the glass roof.

If you want to see other models demonstrating my engine, see
[http://www.camelot.homedns.org/~michalis/miscella/kambi_vrml_examples.zip]
--- there are many testcases and demos of what can be expressed in VRML 1.0
and what my engine can understand and render. See also
[http://www.camelot.homedns.org/~michalis/view3dscene.php] ---
view3dscene is my VRML 1.0 (and 3DS) viewer based on the same engine as
this game.

--------------------
Sources:

Compile with simple
  make build-unix
under Unixes (Linux, FreeBSD) or
  make build-win32
under Windows. Note that you must use GNU make. Note that the only
FPC version that I really support is 2.0.2 (although 2.0.0 is probably
also still OK). There is no Delphi support --- I live in open source world.

I include in this archive all the sources needed to compile the game.
I include also compiled binaries for Linux and Windows, for your comfort.
Also everything needed to tweak with various parts of the game
(e.g. GIMP *.xcf files, that are the "source" version of "png" images,
and Blender's *.blend files that are the "source" version of some "*.wrl" files).

Everything is open source, GNU GPL.

Sources inside units/ subdirectory are not specific to this project.
They are my general units, and together I like to call them
"my 3d game engine" (although there are also many various units that
don't do anything directly related to "3d game engine").
These units are publicly available from my WWW page
[http://www.camelot.homedns.org/~michalis/] ---
see [http://www.camelot.homedns.org/~michalis/sources.php].
Their documentation generated by pasdoc is also available, see
[http://www.camelot.homedns.org/~michalis/sources_docs.php].

Sources specific for this project, "The Castle", are not yet
publicly available from my WWW pages. But they will be published
there at some point (probably right before PGD competition final deadline).

--------------------
Window size:

The game runs only in resolution 800x600.

Reasoning: My practice shows that it's simply too difficult to really make
a game that looks perfect on any resolution, because any 2D graphics
is highly tied to resolution it was prepared for. Scaling 2D graphics,
even using really good algorithms, never results in optimal look.
My game is 3D, but still there are elements displayed in 2D,
so this still matters.

If your current screen resolution is 800x600, the game will
happily run in fullscreen. Otherwise the game will try to resize
your screen to 800x600 first (on exit, the screen size will
be restored to previous size). If this resizing will fail
(for whatever reason, e.g. you have poor graphics driver),
it will run in window sized 800x600.

You can pass command-line option --no-screen-resize (short form: -n)
to disable the automatic screen resizing. Then the game will
run in fullscreen mode only if your current screen size is 800x600,
otherwise it will run in window sized 800x600.

--------------------
Sound:

The game doesn't play any sounds for now, although all the sound units
using OpenAL are compiled in and OpenAL is initialized.
Instructions about installing OpenAL
and command-line options related to OpenAL are described here:
[http://www.camelot.homedns.org/~michalis/openal_notes.php].

As a demo that my OpenAL engine can work, see e.g. my old demo program
[http://www.camelot.homedns.org/~michalis/lets_take_a_walk.php].

--------------------
Versioning:

Version numbers are 0.y.z, where "y" is a stage of PGD competition.
So "version 0.2.0" is what I submit at the end of stage 2 of competition.
"z" is a release number (will be used in later stages when I will want
to give this game to friends to actually test it before submitting to PGD).

Later, when PGD competition will end and I will continue developing
this game on my WWW page [http://www.camelot.homedns.org/~michalis/],
I will switch to my normal versioning scheme
[http://www.camelot.homedns.org/~michalis/versioning.php].

--------------------
Creating levels, 3d objects for my games:

The short 1-sentence instruction is:
Use any 3d modelling program able to create VRML 1.0 files.

VRML 1.0 format has an official specification and my engine is capable
of handling any VRML 1.0 valid files (actually, even more than that ---
see [http://www.camelot.homedns.org/~michalis/kambi_vrml_extensions.php]).
So my engine is not tied to any particular modelling program.

My favourite 3d modeller is Blender, [http://www.blender3d.org/].
It's open source, it's available for Linux (yeah, Windows too
if you insist :), and it has an enormous set of features.
Including good export for VRML 1.0, of course. There are no special
rules for designing in Blender models for my engine --- basically
just do whatever you like (and whatever can be exported to VRML 1.0).
Below I offer some hints.

I often "wrap" (using WWWInline VRML construction) models produced by
Blender inside some small VRML files written by hand.
For example, data/levels/castle_hall_final.wrl is a small VRML file that is
maintained by hand. It sets up some things that were uncomfortable
(or impossible, due to lacks of VRML 1.0 exporter) to set up from Blender,
and includes (using WWWInline node) other VRML file
(data/levels/castle_hall_processed.wrl in this case) that defines geometry,
materials and textures of the level.

Typical things that I write "by hand" are

- Background, NavigationInfo, WorldInfo nodes

  These nodes were introduced in VRML 2 (although I implemented them
  for VRML 1 also). So Blender exporter to VRML 1 does not write
  these nodes. So I just write them by hand.

- PerspectiveCamera node

  Blender exports camera settings, but in an uncomfortable
  format (as a transformation, instead of as VRML camera node).
  This is OK for simple viewing of VRML models, but it's not OK
  if you want to "tweak" VRML models. In particular, it's bad
  when you want to add Background node (see above) and light nodes
  (see hints below) by hand. Then you have to either insert it
  into the middle of Blender's generated VRML file, or use awkward
  coordinates (because of additional transformation).
  So I usually generate camera node by opening model in my view3dscene
  (see [http://www.camelot.homedns.org/~michalis/view3dscene.php])
  and using "Print current camera node (Ctrl+C)" feature.

- Light nodes

  I usually write light nodes in a separate VRML file
  (that contains only light nodes; see e.g. data/levels/castle_hall_lights.wrl).
  This is comfortable, because I usually want to use level lights
  also on other objects (like enemies) that are not part of the level
  object.

  (Also, while Blender exporter can export Blender lights to VRML,
  it doesn't allow me to use all features of VRML lights.)

Moreover, I sometimes want to post-process VRML files generated from
Blender. I use EmacsLisp macros for this (since this is a great language
for text operations, and it's built in my favourite editor :) ).
For example data/levels/castle_hall.wrl in VRML file
exported from Blender (from data/levels/castle_hall.blend),
and it's processed to data/levels/castle_hall_processed.wrl.

3DS notes: Actually, you can also use models in 3DS format instead
of VRML 1.0. So if your favourite 3d modelling program is not able to export
to VRML 1.0 but it's able to export to 3DS --- you can use it too.
But, since 3DS is a closed format, it will never be supported
completely by my engine (just like by any other program, since everyone
has to decode 3DS). In particular, *everything* that can be expressed
in 3DS format and that is understood by me engine can also be expressed
in VRML 1.0. But not vice-versa, i.e. there are some features that
are available with my engine when using VRML 1.0 but are not available
when using 3DS. So the bottom line is: well, you can use 3DS format
with my engine, it works OK, but VRML 1.0 format is just better :)

--------------------
Creating levels, 3d objects for *this* game:

Section above had general comments about how anyone can create
levels and 3d objects that are useful for my VRML units.
This section describes issues specific to the game "The Castle":

Levels:

- When you create new level and you want to play it:

  Basically all you have to do is to add the call to NewGame
  in castlemenu.pas to use your VRML file. Specify there the filename
  of VRML file without the lights and the filename of VRML file
  with only lights.

  (If it's too tiresome for you to recompile castle,
  you can also change the NewGame call
  to include some generic VRML file that always looks like
    WWWInline { name "xxx.wrl" }
  Then you will not have to recompile castle, instead you
  will just need to update the "xxx" in this generic file.

  Of course you can also just override my current files,
  castle_hall_final.wrl and castle_hall_lights.wrl,
  but that's a brutal solution :) ).

- WorldInfo.title field specifies level name, so you want to set
  this to something nice for user.

- When loading level, we search for node named 'LevelBox'.
  Such node should be a parent of some shape (e.g. IndexedFaceSet)
  node. (In other words: in Blender just add a mesh (usually a cube)
  and name it 'LevelBox').

  When such node is found, we calculate it's BoundingBox and remove
  it from the scene. Calculated BoundingBox becomes Level.LevelBox
  value. And Level.LevelBox is used to limit allowed player positions.
  This can be used to disallow player to move to the very edge of
  the level.

  Usually you will add 'LevelBox' node using Blender, you can also
  use my view3dscene --- see command
  'Console -> Print scene bounding box as VRML node'.

- Levels must be oriented such that +Z is "up".
  While all things in my general units are flexible
  and allow any up vector to be used, I made in "The Castle" a couple
  of assumptions that really need +Z to be up.
  (like TItemOnLevel.PlayerCollision).

- All levels should keep the same general sizes. In other words,
  it's *not good* to just make your new level of arbitrary
  size and then set player's avatarSize such that things "look sensible".
  Why ? Because I place items and enemies on the level.
  So size of all these various models must match.

  In other words: just make sure you use "avatarSize [ 1, 2 ]"
  in your level. And force yourself to design a level that "fits"
  such avatarSize.

- For more customized levels, you may want to derive new class
  from TLevel and override there things you want.

Items:

- Item up vector must be +Z.

- Item should be oriented such that:

  Z = 0 plane is the base plane of the item. It will be aligned with the base
  (i.e. lowest Z) of "stub" object placed on the level.

  X = 0 and Y = 0 is the line around which object will rotate
  when shown on the level. It will be aligned with the X, Y middle
  of "stub" object placed on the level.

  I had an idea to just automatically take item's bounding box,
  it's middle X, Y and lowest Z and automatically adjust to this.
  But this would disable some possible visual tricks.

- Size of item model is exactly the size that will be used to display
  it on level, so set this to look good. Sensible default
  is size around 1.0.

- About the "stub" objects on the level:

  You can place items on the level by placing a "stub" object
  on the level with appropriate name.

  When loading, I search for shape nodes that have a parent node
  named like "Item<item-kind-name><quantity>_<ignored>".
  Where "<item-kind-name>" is "LifePotion" or "Sword" or any
  other TItemKind.VRMLNodeName value (see CastleItems unit),
  "<quantity>" is, well, the integer quantity
  ("1" is assumed if "<quantity>" is omitted), and "<ignored>"
  is just anything that will be ignored (you can use this
  to make object names in your model unique,
  which is obviously desirable).

  Some reasoning about convention above: Blender's names
  have quite limited length, that's why CamelCase is used
  for "<item-kind-name>" and components are generally "glued"
  without any "_" or "-" or " " between.

  Such "stub" object is removed from the actual level and
  instead I insert into level an item. Item position is determined
  by stub lowest Z and middle X,Y line (see above).

  You can easily insert such "stub" with Blender --- just insert
  any shape (I usually insert Cube, and set it's rendering to
  "wireframe" in Blender), and then edit Blender's mesh name
  as appropriate.

- Prepare appropriate 2d image of item (to be shown in inventory slots etc.).
  (Once I tried just automatically rendering models inside inventory slots
  but this doesn't look good enough). You can do it however you like.

  My preferred way is to use my raytracer, called rayhunter
  ([http://www.camelot.homedns.org/~michalis/rayhunter.php]):
  set up appropriate light and camera settings and then just render
  item's model to the image. See data/items/images/.

- If this is a weapon, then additionally you want to prepare what I call
  a ScreenImage of this weapon --- this will be displayed on player's
  screen when it's equipped. See data/items/equipped/.

  Once again, you can do this image however you like.
  I used rayhunter to render screen for sword.

- Finally, to really add the item to the game add 1 line to
  CastleItems units in DoInitialization call creating your
  TItemKind instance.

- For some items you may be able to just reuse some existing TItemKind
  class, for others you will want to derive new class from TItemKind
  and override there things you want.

--------------------
Used things:

Code:
- My 3d game engine in units/. You can treat this engine as
  part of this game (I'm actually extending it while developing
  this game...), but it's generally useful.
- My font2pascal was used to generate font,
  see bfnt_bitstreamverasans_m10_unit.pas and mk_fonts.sh
- FPC, of course

Graphics:
- Some of my other programs are used:
  - view3dscene was often used to see how VRMLs look
    (independent of how they look when used in "The Castle"),
    and to generate some VRML pieces, and some other things...
  - rayhunter was used to render items images, see data/items/images/
- Blender
- GIMP
- ImageMagick
- Terragen was used to create sky (see data/skies/).
  This is the only non-open-source component I used... pity :(.
  But I don't know of any (open-source or not) alternative to Terragen.
- Some textures from public domain Golgotha textures.
- Some post-processing of VRML models is done using EmacsLisp,
  see data/kambi-castle-utils.el and data/items/models/Makefile

--------------------
Have fun! All comments are welcome.

Michalis Kamburelis
http://www.camelot.homedns.org/~michalis/
<kambi@users.sourceforge.net> (or <michalis@camelot.homedns.org>)