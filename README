"The Castle"

--------------------
Installing and running:

- For Linux:

  Extract the archive, move the whole `castle' directory to
  - /usr/local/share/castle/ (for system-wide install) or
  - $HOME/.castle.data/ (for installation only for you)
  To make it clear: you should get directories like
  /usr/local/share/castle/data/ or ~/.castle.data/data/ then.

  Run the executable "castle".

- For Windows:

  Extract the archive anywhere you want.

  Run the executable "castle.exe".

Some general notes about command-line options understood by all my
programs are here:
[http://www.camelot.homedns.org/~michalis/common_options.php].

For good performance you need also good OpenGL drivers
for your graphics card installed.

--------------------
Sources:

Compile with simple
  make build-unix
under Unixes (Linux, FreeBSD) or
  make build-win32
under Windows. Note that you must use GNU make. Note that the only
FPC version that I really support is 2.0.2 (although 2.0.0 is probably
also still OK). There is no Delphi support --- I live in open source world.

I include in this archive all the sources needed to compile the game.
I include also compiled binaries for Linux and Windows, for your comfort.
Also everything needed to tweak with various parts of the game
(e.g. GIMP *.xcf files, that are the "source" version of "png" images,
and Blender's *.blend files that are the "source" version of some "*.wrl" files).

Everything is open source, GNU GPL.

Sources inside units/ subdirectory are not specific to this project.
They are my general units, and together I like to call them
"my 3d game engine" (although there are also many various units that
don't do anything directly related to "3d game engine").
These units are publicly available from my WWW page
[http://www.camelot.homedns.org/~michalis/] ---
see [http://www.camelot.homedns.org/~michalis/sources.php].
Their documentation generated by pasdoc is also available, see
[http://www.camelot.homedns.org/~michalis/sources_docs.php].

Sources specific for this project, "The Castle", are not yet
publicly available from my WWW pages. But they will be published
there at some point (probably right before PGD competition final deadline).

--------------------
Sample level included:

Err... I wanted to prepare in Blender a new shiny first level of my game
(castle_hall), but I will not make it in time for stage 2 of PGD competition.
So I just placed here a sample level (basic_castle)
that is actually combined from my old demo castle model,
and I added night sky with moon that was used in
my other toy-game (named "lets_take_a_walk").

Looks good as a demo, but just bear in mind that this basic level is only for
demo purposes, for the next stage it will be replaced with some great
and beautiful and original level created especially for this game.

If you want to see other models demonstrating my engine, see
[http://www.camelot.homedns.org/~michalis/miscella/kambi_vrml_examples.zip]
--- there are many testcases and demos of what can be expressed in VRML 1.0
and what my engine can understand and render. See also
[http://www.camelot.homedns.org/~michalis/view3dscene.php] ---
view3dscene is my VRML 1.0 (and 3DS) viewer based on the same engine as
this game.

--------------------
Window size:

The game runs only in resolution 800x600.

Reasoning: My practice shows that it's simply too difficult to really make
a game that looks perfect on any resolution, because any 2D graphics
is highly tied to resolution it was prepared for. Scaling 2D graphics,
even using really good algorithms, never results in optimal look.
My game is 3D, but still there are elements displayed in 2D,
so this still matters.

If your current screen resolution is 800x600, the game will
happily run in fullscreen. Otherwise the game will try to resize
your screen to 800x600 first (on exit, the screen size will
be restored to previous size). If this resizing will fail
(for whatever reason, e.g. you have poor graphics driver),
it will run in window sized 800x600.

You can pass command-line option --no-screen-resize (short form: -n)
to disable the automatic screen resizing. Then the game will
run in fullscreen mode only if your current screen size is 800x600,
otherwise it will run in window sized 800x600.

--------------------
Sound:

The game doesn't play any sounds for now, although all the sound units
using OpenAL are compiled in and OpenAL is initialized.
Instructions about installing OpenAL
and command-line options related to OpenAL are described here:
[http://www.camelot.homedns.org/~michalis/openal_notes.php].

As a demo that my OpenAL engine can work, see e.g. my old demo program
[http://www.camelot.homedns.org/~michalis/lets_take_a_walk.php].

--------------------
Versioning:

Version numbers are 0.y.z, where "y" is a stage of PGD competition.
So "version 0.2.0" is what I submit at the end of stage 2 of competition.
"z" is a release number (will be used in later stages when I will want
to give this game to friends to actually test it before submitting to PGD).

Later, when PGD competition will end and I will continue developing
this game on my WWW page [http://www.camelot.homedns.org/~michalis/],
I will switch to my normal versioning scheme
[http://www.camelot.homedns.org/~michalis/versioning.php].

--------------------
Creating levels, 3d objects for my games:

The short 1-sentence instruction is:
Use any 3d modelling program able to create VRML 1.0 files.

VRML 1.0 format has an official specification and my engine is capable
of handling any VRML 1.0 valid files (actually, even more than that ---
see [http://www.camelot.homedns.org/~michalis/kambi_vrml_extensions.php]).
So my engine is not tied to any particular modelling program.

My favourite 3d modeller is Blender, [http://www.blender3d.org/].
It's open source, it's available for Linux (yeah, Windows too
if you insist :), and it has an enormous set of features.
Including good export for VRML 1.0, of course. There are no special
rules for designing in Blender models for my engine --- basically
just do whatever you like (and whatever can be exported to VRML 1.0).
Below I offer some hints.

I often "wrap" (using WWWInline VRML construction) models produced by
Blender inside some small VRML files written by hand.
For example, data/castle_hall_final.wrl is a small VRML file that is
maintained by hand. It sets up some things that were uncomfortable
(or impossible, due to lacks of VRML 1.0 exporter) to set up from Blender,
and includes data/castle_hall.wrl (by WWWInline { name "castle_hall.wrl" }).
data/castle_hall.wrl file is simply exported from Blender version
of data/castle_hall.blend. Typical things that I write "by hand" are

- Background node

  (Background nodes were introduced in VRML 2, but I implemented them
  for VRML 1 also. So Blender exporter is not able to export Blender's
  World properties to VRML Background node. So I just write
  Background node by hand.)

- PerspectiveCamera node

  (Blender exports camera settings, but in an uncomfortable
  format (as a transformation, instead of as VRML camera node).
  This is OK for simple viewing of VRML models, but it's not OK
  if you want to "tweak" VRML models. In particular, it's bad
  when you want to add Background node (see above) and light nodes
  (see hints below) by hand. Then you have to either insert it
  into the middle of Blender's generated VRML file, or use awkward
  coordinates (because of additional transformation).
  So I usually generate camera node by opening model in my view3dscene
  (see [http://www.camelot.homedns.org/~michalis/view3dscene.php])
  and using "Print current camera node (Ctrl+C)" feature.

- Light nodes

  I usually write light nodes in a separate VRML file
  (that contains only light nodes; see e.g. data/castle_hall_lights.wrl).
  This is comfortable, because I usually want to use level lights
  also on other objects (like enemies) that are not part of the level
  object.

  (Also, while Blender exporter can export Blender lights to VRML,
  it doesn't allow me to use all features of VRML lights.)

3DS notes: Actually, you can also use models in 3DS format instead
of VRML 1.0. So if your favourite 3d modelling program is not able to export
to VRML 1.0 but it's able to export to 3DS --- you can use it too.
But, since 3DS is a closed format, it will never be supported
completely by my engine (just like by any other program, since everyone
has to decode 3DS). In particular, *everything* that can be expressed
in 3DS format and that is understood by me engine can also be expressed
in VRML 1.0. But not vice-versa, i.e. there are some features that
are available with my engine when using VRML 1.0 but are not available
when using 3DS. So the bottom line is: well, you can use 3DS format
with my engine, it works OK, but VRML 1.0 format is just better :)

--------------------
Creating levels, 3d objects for *this* game:

Section above had general comments about how anyone can create
levels and 3d objects that are useful for my VRML units.
This section describes issues specific to the game "The Castle":

Levels:

- When you create new level and you want to play it:

  All you have to do is to change the call to TCastleLevel.Create
  in castlemenu.pas to use your VRML files. Specify there the filename
  of VRML file without the lights and the filename of VRML file
  with only lights.

  (If it's too tiresome for you to recompile castle,
  you can also change the TCastleLevel.Create call
  to include some generic VRML file that always looks like
    WWWInline { name "xxx.wrl" }
  Then you will not have to recompile castle, instead you
  will just need to update the "xxx" in this generic file.

  Of course you can also just override my current files,
  basic_castle_final.wrl and basic_castle_lights.wrl,
  but that's a brutal solution:) .)

- WorldInfo.title field specifies level name, so you want to set
  this to something nice for user.

- When loading level, we search for node named 'LevelBox'.
  Such node should be a parent of some shape (e.g. IndexedFaceSet)
  node. (In other words: in Blender just add a mesh (usually a cube)
  and name it 'LevelBox').

  When such node is found, we calculate it's BoundingBox and remove
  it from the scene. Calculated BoundingBox becomes Level.LevelBox
  value. And Level.LevelBox is used to limit allowed player positions.
  This can be used to disallow player to move to the very edge of
  the level.

  Usually you will add 'LevelBox' node using Blender, you can also
  use my view3dscene --- see command
  'Console -> Print scene bounding box as VRML node'.

Items:

- Item up vector must be +Z.

- Item should be oriented such that:

  Z = 0 plane is the base plane of the item. It will be aligned with the base
  (i.e. lowest Z) of "stub" object placed on the level.

  X = 0 and Y = 0 is the line around which object will rotate
  when shown on the level. It will be aligned with the X, Y middle
  of "stub" object placed on the level.

  I had an idea to just automatically take item's bounding box,
  it's middle X, Y and lowest Z and automatically adjust to this.
  But this would disable some possible visual tricks.

- Size of item model is exactly the size that will be used to display
  it on level, so set this to look good. Sensible default
  is size around 1.0.

- Around the "stub" objects on the level:

  You can place items on the level by placing a "stub" object
  on the level with appropriate name.

  When loading, I search for shape nodes that have a parent node
  named like "Item_<item-kind-name>_<item-info>".
  Where "<item-kind-name>" is "flaskred" or "sword" or any
  other TItemKind.VRMLNodeName value (see CastleItems unit)
  and "<item-info>" doesn't have any meaning (for now).

  Such "stub" object is removed from the actual level and
  instead I insert into level an item. Item's kind is determined
  by "<item-kind-name>" above, item position is determined
  by stub lowest Z and middle X,Y line (see above).

  You can easily insert such "stub" with Blender --- just insert
  any shape (I usually insert Cube, and set it's rendering to
  "wireframe" in Blender), and then edit Blender's mesh name.

--------------------
Used things:

- Obviously, my 3d game engine in units/.
  Also my view3dscene was often useful to see how VRMLs look
  (independent of how they look when used in "The Castle").
- Blender
- GIMP
- Terragen was used to create sky (see data/skies/).
  This is the only non-open-source component I used... pity :(.
  But I don't know of any (open-source or not) alternative to Terragen.
- Some textures from public domain Golgotha textures.
- Some post-processing of VRML models is done using EmacsLisp,
  see data/kambi-castle-utils.el and data/items/models/Makefile

--------------------
Have fun! All comments are welcome.

Michalis Kamburelis
http://www.camelot.homedns.org/~michalis/
<kambi@users.sourceforge.net> (or <michalis@camelot.homedns.org>)